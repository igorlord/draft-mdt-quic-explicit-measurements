{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-03-02T01:14:49.867650+00:00",
  "repo": "igorlord/draft-mdt-quic-explicit-measurements",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOKHccDc5c6yGp",
      "title": "Update draft-mdt-quic-explicit-measurements.md",
      "url": "https://github.com/igorlord/draft-mdt-quic-explicit-measurements/pull/1",
      "state": "MERGED",
      "author": "giuseppefioccola",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-16T15:45:49Z",
      "updatedAt": "2023-10-16T18:19:05Z",
      "baseRepository": "igorlord/draft-mdt-quic-explicit-measurements",
      "baseRefName": "main",
      "baseRefOid": "af3a4c00dbca7a3129a816a0a74c7dc3c3aa6524",
      "headRepository": "igorlord/draft-mdt-quic-explicit-measurements",
      "headRefName": "giuseppefioccola-patch-1",
      "headRefOid": "ff5109305a04f7c3fd7e40439a030fa3ea674f69",
      "closedAt": "2023-10-16T18:19:04Z",
      "mergedAt": "2023-10-16T18:19:04Z",
      "mergedBy": "igorlord",
      "mergeCommit": {
        "oid": "8dc6ee86ca927876967285bbac8707deb1ae8978"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKHccDc5kLQjJ",
          "commit": {
            "abbreviatedOid": "ff51093"
          },
          "author": "igorlord",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-16T18:09:04Z",
          "updatedAt": "2023-10-16T18:09:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKHccDc5kLUMd",
          "commit": {
            "abbreviatedOid": "ff51093"
          },
          "author": "igorlord",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-16T18:13:02Z",
          "updatedAt": "2023-10-16T18:13:02Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "This document defines an extension to QUIC to enable Packet loss measurements.   It is not defining a technique.",
              "createdAt": "2023-10-16T18:13:02Z",
              "updatedAt": "2023-10-16T18:13:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKHccDc5kLWoW",
          "commit": {
            "abbreviatedOid": "ff51093"
          },
          "author": "igorlord",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-16T18:17:03Z",
          "updatedAt": "2023-10-16T18:17:04Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "> Authentication techniques can be used where appropriate to guard against these traffic attacks.\r\n\r\nThis is likely to raise eyebrows due to imprecision. This is a guide to implementers -- they will want to know the details of at least one technique they can use.",
              "createdAt": "2023-10-16T18:17:03Z",
              "updatedAt": "2023-10-16T18:17:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKHccDc5kLXPO",
          "commit": {
            "abbreviatedOid": "ff51093"
          },
          "author": "igorlord",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "I'll create a PR to address some of my comments.",
          "createdAt": "2023-10-16T18:18:48Z",
          "updatedAt": "2023-10-16T18:18:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 2,
      "id": "PR_kwDOKHccDc5c8Rl8",
      "title": "Igor/quick update",
      "url": "https://github.com/igorlord/draft-mdt-quic-explicit-measurements/pull/2",
      "state": "MERGED",
      "author": "igorlord",
      "authorAssociation": "OWNER",
      "assignees": [
        "giuseppefioccola"
      ],
      "labels": [],
      "body": "A few editorial changes (and white space normalization).",
      "createdAt": "2023-10-16T20:03:16Z",
      "updatedAt": "2023-10-17T03:03:39Z",
      "baseRepository": "igorlord/draft-mdt-quic-explicit-measurements",
      "baseRefName": "main",
      "baseRefOid": "8dc6ee86ca927876967285bbac8707deb1ae8978",
      "headRepository": "igorlord/draft-mdt-quic-explicit-measurements",
      "headRefName": "igor/quick-update",
      "headRefOid": "ac4db9c2a75cf5b4ae3f559d96d0d95815263ff4",
      "closedAt": "2023-10-17T03:03:38Z",
      "mergedAt": "2023-10-17T03:03:38Z",
      "mergedBy": "igorlord",
      "mergeCommit": {
        "oid": "72b7bc63b03ab39ce50b473fbb10088e9fa3826f"
      },
      "comments": [
        {
          "author": "igorlord",
          "authorAssociation": "OWNER",
          "body": "> Two nits, otherwise okay for me ;)\r\n\r\nThank you for fixing these.",
          "createdAt": "2023-10-17T03:02:58Z",
          "updatedAt": "2023-10-17T03:02:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKHccDc5kMGjx",
          "commit": {
            "abbreviatedOid": "ac4db9c"
          },
          "author": "ferrieux",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Two nits, otherwise okay for me ;)",
          "createdAt": "2023-10-16T20:21:34Z",
          "updatedAt": "2023-10-16T20:21:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOKHccDc5dJvx_",
      "title": "Update to draft-mdt-quic-explicit-measurements",
      "url": "https://github.com/igorlord/draft-mdt-quic-explicit-measurements/pull/3",
      "state": "CLOSED",
      "author": "massimon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Our proposal for the implementation section and other minor changes.",
      "createdAt": "2023-10-18T14:51:26Z",
      "updatedAt": "2024-03-04T12:11:29Z",
      "baseRepository": "igorlord/draft-mdt-quic-explicit-measurements",
      "baseRefName": "main",
      "baseRefOid": "72b7bc63b03ab39ce50b473fbb10088e9fa3826f",
      "headRepository": "igorlord/draft-mdt-quic-explicit-measurements",
      "headRefName": "nilo-patch-1",
      "headRefOid": "95205ffa3ae87ee316328e79e4ea8218376fb2a6",
      "closedAt": "2024-03-04T12:11:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKHccDc5kdVeS",
          "commit": {
            "abbreviatedOid": "d6f9501"
          },
          "author": "ferrieux",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T15:27:02Z",
          "updatedAt": "2023-10-18T15:27:03Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "So you're proposing to switch from \"opt-out\" (where any endpoint can select to disable the feature) top \"opt-in\" (where any endpoint can \"force\" the other to enable it) ?\r\nIf yes, it is an uphill battle, as the Spin Bit only made it under the condition of opt-out.",
              "createdAt": "2023-10-18T15:27:03Z",
              "updatedAt": "2023-10-18T15:27:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKHccDc5kgT_B",
          "commit": {
            "abbreviatedOid": "95205ff"
          },
          "author": "igorlord",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-10-18T21:35:10Z",
          "updatedAt": "2023-10-18T21:45:39Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Moreover, it is not implementable, and the MUST is not verifiable.\r\nIf a particular implementation does not support this extension, how can the other endpoint expect a change of behavior from an unsupporting implementation?",
              "createdAt": "2023-10-18T21:35:10Z",
              "updatedAt": "2023-10-18T21:46:23Z"
            },
            {
              "originalPosition": 56,
              "body": "Do you mean here that the endpoint sending `enable_network_troubleshooting` parameter SHOULD (why not MUST?) enable QUIC latency spin bit?  Or you do mean that when `enable_network_troubleshooting` parameter is used by both endpoints then endpoints SHOULD/MUST enable QUIC latency spin bit?",
              "createdAt": "2023-10-18T21:40:07Z",
              "updatedAt": "2023-10-18T21:45:39Z"
            },
            {
              "originalPosition": 111,
              "body": "Same as above -- an endpoint cannot unilaterally force another endpoint to support a protocol extension, especially since that extension may not even be implemented by the protocol.",
              "createdAt": "2023-10-18T21:43:17Z",
              "updatedAt": "2023-10-18T21:45:39Z"
            },
            {
              "originalPosition": 39,
              "body": "I like this change a lot.  It is very generic and purposeful.  As discussed below, however, we _may_ still want to maintain an ability to say: \"I will allow you to use reserved bits for this purpose, but I will not send my own loss information to you.\"",
              "createdAt": "2023-10-18T21:43:51Z",
              "updatedAt": "2023-10-18T21:45:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKHccDc5kjOZV",
          "commit": {
            "abbreviatedOid": "95205ff"
          },
          "author": "ferrieux",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T07:46:41Z",
          "updatedAt": "2023-10-19T07:46:41Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "+1: this asymmetric (but now bilaterally agreed) mode is what makes (e.g.) the QL deployable at large scale: the server asks the permission to send, many clients grant it, but they don't have any need to implement more than the TP-accept code.",
              "createdAt": "2023-10-19T07:46:41Z",
              "updatedAt": "2023-10-19T07:46:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 4,
      "id": "PR_kwDOKHccDc5di532",
      "title": "Update draft-mdt-quic-explicit-measurements.md",
      "url": "https://github.com/igorlord/draft-mdt-quic-explicit-measurements/pull/4",
      "state": "MERGED",
      "author": "massimon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-23T15:29:56Z",
      "updatedAt": "2023-10-23T15:59:57Z",
      "baseRepository": "igorlord/draft-mdt-quic-explicit-measurements",
      "baseRefName": "main",
      "baseRefOid": "72b7bc63b03ab39ce50b473fbb10088e9fa3826f",
      "headRepository": "igorlord/draft-mdt-quic-explicit-measurements",
      "headRefName": "nilo-patch-2",
      "headRefOid": "7a206a690c9e41b6955a38cf74dff380c6caf94f",
      "closedAt": "2023-10-23T15:59:56Z",
      "mergedAt": "2023-10-23T15:59:56Z",
      "mergedBy": "giuseppefioccola",
      "mergeCommit": {
        "oid": "cea3f306c0c794f9fb41d126de3e0bf2467a1ea0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 5,
      "id": "PR_kwDOKHccDc5olP9b",
      "title": "Small revision",
      "url": "https://github.com/igorlord/draft-mdt-quic-explicit-measurements/pull/5",
      "state": "MERGED",
      "author": "giuseppefioccola",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-03-04T12:10:36Z",
      "updatedAt": "2024-03-04T12:11:46Z",
      "baseRepository": "igorlord/draft-mdt-quic-explicit-measurements",
      "baseRefName": "main",
      "baseRefOid": "4b379e9576d45881d0d5358e8336d2474333d196",
      "headRepository": "igorlord/draft-mdt-quic-explicit-measurements",
      "headRefName": "fabio-patch-1",
      "headRefOid": "b5ba314b3366ce2e045625d3d9bf6993ba1be5c9",
      "closedAt": "2024-03-04T12:11:45Z",
      "mergedAt": "2024-03-04T12:11:45Z",
      "mergedBy": "giuseppefioccola",
      "mergeCommit": {
        "oid": "80bec7f23cb1d942297f471ee696a997d25ed1e9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 6,
      "id": "PR_kwDOKHccDc6MTRss",
      "title": "Use explicit measurement protocol packet",
      "url": "https://github.com/igorlord/draft-mdt-quic-explicit-measurements/pull/6",
      "state": "MERGED",
      "author": "ihlar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a proposal to use explicit measurement protocol packets that are coalesced with QUIC packets in UDP datagrams, similar to what is proposed in https://datatracker.ietf.org/doc/draft-thomson-scone-train-protocol/.\r\n\r\nNote that this mechanism allows for the use of more bits, in this PR I propose that the spin bit value is copied from an inner QUIC packet to the outer measurement packet.\r\n\r\nI will likely do another pass on language and formatting, but let's discuss the merits of the general proposal first. ",
      "createdAt": "2025-02-24T14:38:14Z",
      "updatedAt": "2025-02-28T11:03:47Z",
      "baseRepository": "igorlord/draft-mdt-quic-explicit-measurements",
      "baseRefName": "main",
      "baseRefOid": "80bec7f23cb1d942297f471ee696a997d25ed1e9",
      "headRepository": "ihlar/draft-mdt-quic-explicit-measurements",
      "headRefName": "patch-1",
      "headRefOid": "d0c749f121d3cb2c729664e521ba33c54f210685",
      "closedAt": "2025-02-28T11:03:46Z",
      "mergedAt": "2025-02-28T11:03:46Z",
      "mergedBy": "giuseppefioccola",
      "mergeCommit": {
        "oid": "8f652105fff682ac019f3430b2c1e18a5bfb5d33"
      },
      "comments": [
        {
          "author": "ihlar",
          "authorAssociation": "COLLABORATOR",
          "body": "Good comments, we might want to open issues for a few of these. \r\n\r\n> (1) is there \"room\" in the long-header EFMP datagram for integrity protection ? If not, we need to acknowledge the fact that we trust all network elements on the path to \"play fair\", by not polluting (nor bleaching) the signal... \r\n\r\nI think there are several ways one could do integrity protection of the bits, but it'd likely require some more space. \r\nFirst of all, we need to consider the threat model, since any integrity protection would be validated by endpoints alone. \r\nSince it's only 6 bits we're concerned with here a simple solution could be to simply replicate the bits in a QUIC frame sent within the crypto envelope of an \"inner\" QUIC packet. \r\n\r\n> (2) since there are a few spare bits, what about enriching the Spin Bit with the VEB (Valid Edge Bit) invented by Piet De Vaere (then PhD student of Brian Trammel, who might remember ;-). The result from Piet's work is that the VEB hugely improves the Spin Bit's reliability in the face of loss and reordering. \r\n\r\nI absolutely think we should consider using the additional bits, rather than letting them be spare. \r\n\r\n> (3) talking about spare bits, why stop at just one byte, given the overheaded of the version number and optional Cids ? Indeed, if you can insert two extra 32-bit words, you can use them to carry Loss Counters (the integral of Q and L) instead of sending Loss Bits (unary form). This, like the VEB, would render the Q+L measurement superiorly resilient to network problems. What do you think ?\r\n\r\nWe need to be a bit careful here. Yes we can definitely create a more powerful signal, but every piece of overhead matter. The location of the 32 bit words would not be at a fixed offset, so processing becomes a bit more expensive. We'd now have additional data to consider for the integrity protection as well (if we determine it to be necessary). OTH, if the counters do not need to be present in each packet it might be a more acceptable tradeoff.  \r\n",
          "createdAt": "2025-02-25T13:00:07Z",
          "updatedAt": "2025-02-25T13:00:07Z"
        },
        {
          "author": "igorlord",
          "authorAssociation": "OWNER",
          "body": "> > (1) is there \"room\" in the long-header EFMP datagram for integrity protection ? If not, we need to acknowledge the fact that we trust all network elements on the path to \"play fair\", by not polluting (nor bleaching) the signal...\r\n> \r\n> I think there are several ways one could do integrity protection of the bits, but it'd likely require some more space. First of all, we need to consider the threat model, since any integrity protection would be validated by endpoints alone. Since it's only 6 bits we're concerned with here a simple solution could be to simply replicate the bits in a QUIC frame sent within the crypto envelope of an \"inner\" QUIC packet.\r\n\r\nIntegrity protection here is tricky.  The threat model is someone who is able to inject packets into the network flow or, worse, modify in-flight packets.  While end-to-end cryptographic protection is possible, observers do not have the keys, so I am not sure how an observer is able to detect a tampered packet or a packet manufactured by a third party.\r\n\r\nSince QUIC wants to be able to protect against attackers who are only able to inject packets but are unable to alter or drop packets, QUIC endpoints will simply drop packets that fail cryptographic validation.  So by manufacturing fake EFMP packets, the 3rd party attacker can mislead an observer while leaving the actual QUIC flow undisturbed.",
          "createdAt": "2025-02-25T14:31:09Z",
          "updatedAt": "2025-02-25T14:32:29Z"
        },
        {
          "author": "ferrieux",
          "authorAssociation": "COLLABORATOR",
          "body": "> \r\n> Integrity protection here is tricky. The threat model is someone who is able to inject packets into the network flow or, worse, modify in-flight packets. While end-to-end cryptographic protection is possible, observers do not have the keys, so I am not sure how an observer is able to detect a tampered packet or a packet manufactured by a third party.\r\n\r\nIntegrity protection is not encryption, so the observers can be supposed to have the (public) key that permits verification. Only the sender (server) has the private key allowing to generate valid signatures. And it may publish the associated public key through DNS for example.\r\n\r\n> Since QUIC wants to be able to protect against attackers who are only able to inject packets but are unable to alter or drop packets, QUIC endpoints will simply drop packets that fail cryptographic validation. So by manufacturing fake EFMP packets, the 3rd party attacker can mislead an observer while leaving the actual QUIC flow undisturbed.\r\n\r\nYes. I have no worries about QUIC's robustness in that matter. Only *our* signal is a bit weakened if anybody can tamper with it.\r\n\r\nAlso, as QUIC is innocuous to stray packets, let me re-propose what I already suggested: just insert standalone packets (instead of datagrams \"glued\" before real QUIC ones, as is proposed here)  in the same 5-tuple. These packets may just superficially resemble QUIC (e.g. the first byte) so that it's not too easy for nasty firewalls to drop them, but no need to abide by the rest of the QUIC ritual (like VN or CID), just our payload and a signature. And no, I'm not taking the Spin Bit aboard as (1) it is already present in QUIC, and (2) needs bidirectional dance that the QL signal doesn't, and would be tricky to implement as our packets are *meant* to be handled as garbage by the receiver's QUIC stack. \r\n\r\nStill not interested ?\r\n\r\n",
          "createdAt": "2025-02-25T15:23:45Z",
          "updatedAt": "2025-02-25T15:24:46Z"
        },
        {
          "author": "igorlord",
          "authorAssociation": "OWNER",
          "body": "> the observers can be supposed to have the (public) key that permits verification\r\n\r\nThis is rather hard to deploy generally across Internet, but this could be possible to do within a controlled environment (like TI handsets having a private key that TI observer equipment knows a public key for). Controlled environments might be less suseptable to tampering, though. Generic DNS distribution may be hard -- the observer might not know SNI for the traffic, and SNI identifies just the server endpoint anyway.\r\n\r\n> just insert standalone packets (instead of datagrams \"glued\" before real QUIC ones, as is proposed here) in the same 5-tuple. These packets may just superficially resemble QUIC (e.g. the first byte) so that it's not too easy for nasty firewalls to drop them\r\n\r\nIf observers can identify these packets, so can nasty firewalls. It may actually be harder to \"unglue\" the special datagrams than to drop \"garbage\" packets.",
          "createdAt": "2025-02-25T16:02:02Z",
          "updatedAt": "2025-02-25T16:02:02Z"
        },
        {
          "author": "ferrieux",
          "authorAssociation": "COLLABORATOR",
          "body": "> > the observers can be supposed to have the (public) key that permits verification\r\n> \r\n> This is rather hard to deploy generally across Internet, but this could be possible to do within a controlled environment (like TI handsets having a private key that TI observer equipment knows a public key for). Controlled environments might be less suseptable to tampering, though. Generic DNS distribution may be hard -- the observer might not know SNI for the traffic, and SNI identifies just the server endpoint anyway.\r\n\r\nHonestly, you know fairly well from our field experiment that the download direction is the most important for troubleshooting; so only the server's key matters, not the handset's. Also, if the IP-FQDN is indeed tricky,  the server can publish its pubkey directly under https://IP . Or even in-band, as an addendum to one EFMP packet out of (say) 100 .\r\n\r\n> \r\n> > just insert standalone packets (instead of datagrams \"glued\" before real QUIC ones, as is proposed here) in the same 5-tuple. These packets may just superficially resemble QUIC (e.g. the first byte) so that it's not too easy for nasty firewalls to drop them\r\n> \r\n> If observers can identify these packets, so can nasty firewalls. It may actually be harder to \"unglue\" the special datagrams than to drop \"garbage\" packets.\r\n\r\nMy suggestion was not to improve the stray-dropping issue; instead, it was about taking advantage of QUIC's robustness to alien-crypto contents. This is indeed liberating as it allows for much more bits.\r\n\r\n",
          "createdAt": "2025-02-25T16:50:14Z",
          "updatedAt": "2025-02-25T16:50:14Z"
        },
        {
          "author": "giuseppefioccola",
          "authorAssociation": "COLLABORATOR",
          "body": "I propose to merge this PR and submit the new revision of the draft.\r\nWe can leave the open points (e.g. integrity protection, use of more bits,...) for the next version.",
          "createdAt": "2025-02-27T15:06:51Z",
          "updatedAt": "2025-02-27T15:06:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOKHccDc6dN296",
          "commit": {
            "abbreviatedOid": "3a336ad"
          },
          "author": "igorlord",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-24T16:00:16Z",
          "updatedAt": "2025-02-24T16:00:17Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "willing to **receive**?",
              "createdAt": "2025-02-24T16:00:17Z",
              "updatedAt": "2025-02-24T16:00:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKHccDc6dOHLo",
          "commit": {
            "abbreviatedOid": "d015d70"
          },
          "author": "ferrieux",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-24T16:23:24Z",
          "updatedAt": "2025-02-24T16:23:25Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Typo EMPP->EFMP",
              "createdAt": "2025-02-24T16:23:24Z",
              "updatedAt": "2025-02-24T16:23:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKHccDc6dOSHQ",
          "commit": {
            "abbreviatedOid": "3a336ad"
          },
          "author": "ferrieux",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice !\r\nA few tangents:\r\n(1) is there \"room\" in the long-header EFMP datagram for integrity protection ? If not, we need to acknowledge the fact that we trust all network elements on the path to \"play fair\", by not polluting (nor bleaching) the signal...\r\n(2) since there are a few spare bits, what about enriching the Spin Bit with the VEB (Valid Edge Bit) invented by Piet De Vaere (then PhD student of Brian Trammel, who might remember ;-). The result from Piet's work is that the VEB hugely improves the Spin Bit's reliability in the face of loss and reordering.\r\n(3) talking about spare bits, why stop at just one byte, given the overheaded of the version number and optional Cids ? Indeed, if you can insert two extra 32-bit words, you can use them to carry Loss Counters (the integral of Q and L) instead of sending Loss Bits (unary form). This, like the VEB, would render the Q+L measurement superiorly resilient to network problems. \r\nWhat do you think ?",
          "createdAt": "2025-02-24T16:38:05Z",
          "updatedAt": "2025-02-24T16:38:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOKHccDc6dYxUg",
          "commit": {
            "abbreviatedOid": "3a336ad"
          },
          "author": "ihlar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-25T10:22:25Z",
          "updatedAt": "2025-02-25T10:22:25Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "I put send here explicitly since I saw that in the IANA considerations section you had the following text: \r\n\"Specification: Indicates that the endpoint supports network_troubleshooting. An endpoint that advertises this transport parameter can receive loss bits. An endpoint that advertises this transport parameter with value 1 can also send loss bits.\"",
              "createdAt": "2025-02-25T10:22:25Z",
              "updatedAt": "2025-02-25T10:22:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKHccDc6dbdfz",
          "commit": {
            "abbreviatedOid": "5625d1c"
          },
          "author": "igorlord",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-02-25T14:16:43Z",
          "updatedAt": "2025-02-25T14:16:52Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "IANA considerations section aside, this section describes the `efmp_supported` TP, and so it should describe it fully.  I would say something like:\r\n\r\n> : efmp_supported transport parameter is an integer value, encoded as a\r\n> variable-length integer, that can be set to 0 or 1, indicating the level of\r\n> EFMP support. The value of 0 indicates that the endpoint is able to receive\r\n> EFMP packets but will not be sending any, while the value of 1 indicates\r\n> that the endpoint is also willing to send EFMP packets.",
              "createdAt": "2025-02-25T14:16:43Z",
              "updatedAt": "2025-02-25T14:37:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOKHccDc6d1K1o",
          "commit": {
            "abbreviatedOid": "d0c749f"
          },
          "author": "igorlord",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-27T14:26:51Z",
          "updatedAt": "2025-02-27T14:26:51Z",
          "comments": []
        }
      ]
    }
  ]
}